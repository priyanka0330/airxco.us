{"request":{"hurl":"https:\/\/airxco.us\/wp-content\/themes\/transport\/js\/gmap3.min.js","inline":"","enable_minification":true,"type":"js","handle":"gmap3","version":""},"log":{"url":"\/wp-content\/themes\/transport\/js\/gmap3.min.js","success":true},"code":"\/*!\n *  GMAP3 Plugin for jQuery\n *  Version  : 7.1\n *  Date     : 2016\/04\/17\n *  Author   : DEMONTE Jean-Baptiste\n *  Contact  : jbdemonte@gmail.com\n *  Web site : http:\/\/gmap3.net\n *  Licence  : GPL-3.0+\n *\/\n(function ($, window, document) {\n  \"use strict\";\n\n  var gm, services = {}, loadOptions,\n\n  \/\/ Proxify functions to get shorter minimized code\n    when = $.when,\n    extend = $.extend,\n    isArray = $.isArray,\n    isFunction = $.isFunction,\n    deferred = $.Deferred;\n\n  \/**\n   * Duplicate option to never modify original object\n   * @param {Object} options\n   * @returns {Object}\n   *\/\n  function dupOpts(options) {\n    return extend(true, {}, options || {});\n  }\n\n  \/**\n   * Slice an array like\n   * @params {Array|Object}\n   * @params {Number} [start]\n   * @params {Number} [end]\n   * @returns {Array}\n   *\/\n  function slice() {\n    var fn = Array.prototype.slice,\n      args = fn.call(arguments, 1);\n    return fn.apply(arguments[0], args);\n  }\n\n  \/**\n   * Return true if value is undefined\n   * @param {*} value\n   * @returns {Boolean}\n   *\/\n  function isUndefined(value) {\n    return typeof value === 'undefined';\n  }\n\n  \/**\n   * Equivalent to Promise.all\n   * @param {Deferred[]} deferreds\n   * @returns {Deferred}\n   *\/\n  function all(deferreds) {\n    return when.apply($, deferreds);\n  }\n\n  \/**\n   * Equivalent to Promise.resolve\n   * @param {*} value\n   * @returns {Deferred}\n   *\/\n  function resolved(value) {\n    return when().then(function () {\n      return value;\n    });\n  }\n\n  \/**\n   * return the distance between 2 latLng in meters\n   * @param {LatLng} origin\n   * @param {LatLng} destination\n   * @returns {Number}\n   **\/\n  function distanceInMeter(origin, destination) {\n    var m = Math,\n      pi = m.PI,\n      e = pi * origin.lat() \/ 180,\n      f = pi * origin.lng() \/ 180,\n      g = pi * destination.lat() \/ 180,\n      h = pi * destination.lng() \/ 180,\n      cos = m.cos,\n      sin = m.sin;\n    return 1000 * 6371 * m.acos(m.min(cos(e) * cos(g) * cos(f) * cos(h) + cos(e) * sin(f) * cos(g) * sin(h) + sin(e) * sin(g), 1));\n  }\n\n  function ready(fn) {\n    if (document.readyState != 'loading'){\n      fn();\n    } else {\n      document.addEventListener('DOMContentLoaded', fn);\n    }\n  }\n\n  function serialize(obj) {\n    return objectKeys(obj).map(function (key) {\n      return encodeURIComponent(key) + \"=\" + encodeURIComponent(obj[key]);\n    }).join(\"&\");\n  }\n\n  \/\/ Auto-load google maps library if needed\n  (function () {\n    var dfd = deferred(),\n      cbName = '__gmap3',\n      script;\n\n    $.holdReady(true);\n\n    ready(function () {\n      if (window.google && window.google.maps || loadOptions === false) {\n        dfd.resolve();\n      } else {\n        \/\/ callback function - resolving promise after maps successfully loaded\n        window[cbName] = function () {\n          delete window[cbName];\n          dfd.resolve();\n        };\n        script = document.createElement('script');\n        script.type = 'text\/javascript';\n        script.src = 'https:\/\/maps.googleapis.com\/maps\/api\/js?callback=' + cbName + (loadOptions ? '&' + (typeof loadOptions === 'string' ? loadOptions : serialize(loadOptions)) : '');\n        $(\"head\").append(script);\n      }\n    });\n\n    return dfd.promise();\n  })().then(function () {\n    $.holdReady(false);\n  });\n\n  \/**\n   * Instantiate only once a google service\n   * @param {String} name\n   * @returns {Object}\n   *\/\n  function service(name) {\n    if (!services[name]) {\n      services[name] = gmElement(name);\n    }\n    return services[name];\n  }\n\n  \/**\n   * Return GoogleMap Class (or overwritten by user) instance\n   * @param {String} name\n   * @returns {Object}\n   *\/\n  function gmElement(name) {\n    var cls = gm[name];\n\n    function F(args) {\n      return cls.apply(this, args);\n    }\n    F.prototype = cls.prototype;\n\n    return new F(slice(arguments, 1));\n  }\n\n  \/**\n   * Resolve a GeocodeRequest\n   * https:\/\/developers.google.com\/maps\/documentation\/javascript\/geocoding\n   * @param {String|Object} request\n   * @returns {Deferred}\n   *\/\n  function geocode(request) {\n    var dfd = deferred();\n    if (typeof request === 'string') {\n      request = {\n        address: request\n      };\n    }\n    service('Geocoder').geocode(request, function(results, status) {\n      if (status === gm.GeocoderStatus.OK) {\n        dfd.resolve(results[0].geometry.location);\n      } else {\n        dfd.reject();\n      }\n    });\n    return dfd;\n  }\n\n  \/**\n   * Callable function taking a parameter as string\n   * @callback StringCallback\n   * @param {String}\n   *\/\n\n  \/**\n   * Split a string and execute a function on each item\n   * @param {String} str - Space separated list of items\n   * @param {StringCallback} fn - Callback function\n   *\/\n  function foreachStr(str, fn) {\n    str.split(' ').forEach(fn);\n  }\n\n  \/**\n   * Execute a function on each items if items is an array and on items as a single element if it is not an array\n   * @param {Array|*} items - Items to execute foreach callback on\n   * @param {Function} fn - Callback function\n   *\/\n  function foreach(items, fn) {\n    (isArray(items) ? items : [items]).forEach(fn);\n  }\n\n  \/**\n   * Return Object keys\n   * @param {Object} obj\n   * @returns {String[]}\n   *\/\n  function objectKeys(obj) {\n    return Object.keys(obj);\n  }\n\n  \/**\n   * Return Object values\n   * @param {Object} obj\n   * @returns {*[]}\n   *\/\n  function objectValues(obj) {\n    return objectKeys(obj).map(function (key) {\n      return obj[key];\n    });\n  }\n\n  \/**\n   * Resolution function\n   * @callback OptionCallback\n   * @param {Object} options\n   * @returns {Deferred|*}\n   *\/\n\n  \/**\n   * Convert bounds from array [ n, e, s, w ] to google.maps.LatLngBounds\n   * @param {Object} options - Container of options.bounds\n   * @param {OptionCallback} fn\n   * @returns {Deferred}\n   *\/\n  function resolveLatLngBounds(options, fn) {\n    options = dupOpts(options);\n    if (options.bounds) {\n      options.bounds = toLatLngBound(options.bounds);\n    }\n    return resolved(fn(options));\n  }\n\n  \/**\n   * Resolve an address location \/ convert a LatLng array to google.maps.LatLng object\n   * @param {Object} options\n   * @param {String} key - LatLng key name in options object\n   * @param {OptionCallback} fn\n   * @returns {Deferred}\n   *\/\n  function resolveLatLng(options, key, fn) {\n    var dfd = deferred();\n    options = dupOpts(options);\n    when()\n      .then(function () {\n        var address = options.address;\n        if (address) {\n          delete options.address;\n          return geocode(address).then(function (latLng) {\n            options[key] = latLng;\n          });\n        }\n        options[key] = toLatLng(options[key]);\n      })\n      .then(function () {\n        dfd.resolve(fn(options));\n      });\n    return dfd;\n  }\n\n  \/**\n   * Convert an array of mixed LatLng to google.maps.LatLng object\n   * No address resolution here\n   * @param {Object} options\n   * @param {String} key - Array key name in options object\n   * @param {OptionCallback} fn\n   * @returns {Deferred}\n   *\/\n  function resolveArrayOfLatLng(options, key, fn) {\n    options = dupOpts(options);\n    options[key] = (options[key] || []).map(function (item) {\n      return toLatLng(item);\n    });\n    return resolved(fn(options));\n  }\n\n  \/**\n   * Convert a LatLng array to google.maps.LatLng\n   * @param {Array|*} mixed\n   * @param {Boolean} [convertLiteral]\n   * @returns {LatLng}\n   *\/\n  function toLatLng(mixed, convertLiteral) {\n    return isArray(mixed) ? new gm.LatLng(mixed[0], mixed[1]) : (convertLiteral && mixed && !(mixed instanceof gm.LatLng) ? new gm.LatLng(mixed.lat, mixed.lng) : mixed);\n  }\n\n  \/**\n   * Convert a LatLngBound array to google.maps.LatLngBound\n   * @param {Array|*} mixed\n   * @param {Boolean} [convertLiteral]\n   * @returns {LatLngBounds}\n   *\/\n  function toLatLngBound(mixed, convertLiteral) {\n    if (isArray(mixed)) {\n      return new gm.LatLngBounds({lat: mixed[2], lng: mixed[3]}, {lat: mixed[0], lng: mixed[1]});\n    } else if (convertLiteral && !mixed.getCenter){\n      return new gm.LatLngBounds({lat: mixed.south, lng: mixed.west}, {lat: mixed.north, lng: mixed.east});\n    }\n    return mixed;\n  }\n\n  \/**\n   * Create a custom overlay view\n   * @param {Map} map\n   * @param {Object} options\n   * @returns {OverlayView}\n   *\/\n  function createOverlayView(map, options) {\n\n    var GMOverlayView = gm.OverlayView;\n\n    var $div = $(document.createElement(\"div\"))\n      .css({\n        border: \"none\",\n        borderWidth: 0,\n        position: \"absolute\"\n      })\n      .append(options.content);\n\n    options = extend({x: 0, y: 0}, options);\n\n    if (options.position) {\n      options.position = toLatLng(options.position, true);\n    } else if (options.bounds) {\n      options.bounds = toLatLngBound(options.bounds, true);\n    }\n\n    \/**\n     * Class OverlayView\n     * @constructor\n     *\/\n    function OverlayView() {\n      var self = this,\n        listeners = [];\n\n      GMOverlayView.call(self);\n      self.setMap(map);\n\n      function fromLatLngToDivPixel(latlng) {\n        return self.getProjection().fromLatLngToDivPixel(latlng);\n      }\n\n      self.onAdd = function () {\n        var panes = self.getPanes();\n        panes.overlayMouseTarget.appendChild($div[0]);\n      };\n\n      if (options.position) {\n        self.getPosition = function () {\n          return options.position;\n        };\n\n        self.setPosition = function (latlng) {\n          options.position = latlng;\n          self.draw();\n        };\n\n        self.draw = function () {\n          var ps = fromLatLngToDivPixel(options.position);\n          $div.css({\n            left: (ps.x + options.x) + 'px',\n            top: (ps.y + options.y) + 'px'\n          });\n        };\n      } else {\n        self.getBounds = function () {\n          return options.bounds;\n        };\n\n        self.setBounds = function (bounds) {\n          options.bounds = bounds;\n          self.draw();\n        };\n\n        self.draw = function() {\n          var sw = fromLatLngToDivPixel(options.bounds.getSouthWest());\n          var ne = fromLatLngToDivPixel(options.bounds.getNorthEast());\n\n          $div.css({\n            left: (sw.x + options.x) + 'px',\n            top: (ne.y + options.y) + 'px',\n            width: (ne.x - sw.x + options.x) + 'px',\n            height: (sw.y - ne.y + options.y) + 'px'\n          });\n        };\n      }\n\n      self.onRemove = function () {\n        listeners.map(function (handler) {\n          gm.event.removeListener(handler);\n        });\n        $div.remove();\n        self.$ = $div = null; \/\/ mem leaks\n      };\n\n      self.$ = $div;\n    }\n\n    OverlayView.prototype = new GMOverlayView();\n\n    return new OverlayView();\n  }\n\n  \/**\n   * Return a map projection\n   * @param {Map} map\n   * @returns {*}\n   *\/\n  function getProjection(map) {\n    function Overlay() {\n      var self = this;\n      self.onAdd = self.onRemove = self.draw = function () {};\n      return gm.OverlayView.call(self);\n    }\n    Overlay.prototype = new gm.OverlayView();\n    var overlay = new Overlay();\n    overlay.setMap(map);\n    return overlay.getProjection();\n  }\n\n  \/**\n   * Class used as event first parameter on clustering overlays\n   * @param {Cluster} cluster\n   * @param {Marker[]} markers\n   * @param {OverlayView} overlay\n   * @param {LatLngBounds} bounds\n   * @constructor\n   *\/\n  function ClusterOverlay(cluster, markers, overlay, bounds) {\n    var self = this;\n    self.cluster = cluster;\n    self.markers = markers;\n    self.$ = overlay.$;\n    self.overlay = overlay;\n\n    overlay.getBounds = function () {\n      return gmElement('LatLngBounds', bounds.getSouthWest(), bounds.getNorthEast());\n    };\n  }\n\n  \/**\n   * Cluster Group definition.\n   * @typedef {Object} ClusterGroupDef\n   * @property {String|jQuery} content\n   * @property {Number} [x] Offset\n   * @property {Number} [y] Offset\n   *\/\n\n  \/**\n   * Cluster evaluation function\n   * @callback clusterCallback\n   * @param {Marker[]} markers\n   * @return {ClusterGroupDef|undefined}\n   *\/\n\n  \/**\n   * Class used to handle clustering\n   * @param {Map} map\n   * @param {Object} options\n   * @param {Integer} [options.size]\n   * @param {Object[]} [options.markers] markers definition\n   * @param {clusterCallback} [options.cb] callback used to evaluate clustering elements\n   * @constructor\n   *\/\n  function Cluster(map, options) {\n    var timer, igniter, previousViewHash, projection, filter,\n      self = this,\n      markers = [],\n      radius = (options.size || 200) >> 1,\n      enabled = true,\n      overlays = {},\n      handlers = [];\n\n    options = options || {};\n    options.markers = options.markers || [];\n\n    \/**\n     * Cluster evaluation function\n     * @callback bindCallback\n     * @param {ClusterOverlay[]} instances\n     *\/\n\n    \/**\n     * Bind a function to each current or future overlays\n     * @param {bindCallback} fn\n     *\/\n    self._b = function (fn) {\n      fn(objectValues(overlays));\n      handlers.push(fn);\n    };\n\n    \/**\n     * Get the marker list\n     * @returns {Marker[]}\n     *\/\n    self.markers = function () {\n      return slice(markers);\n    };\n\n    \/**\n     * Get the current groups\n     * @returns {ClusterOverlay[]}\n     *\/\n    self.groups = function () {\n      return objectValues(overlays);\n    };\n\n    \/**\n     * Enable the clustering feature\n     *\/\n    self.enable = function () {\n      if (!enabled) {\n        enabled = true;\n        previousViewHash = '';\n        delayRedraw();\n      }\n    };\n\n\n    \/**\n     * Disable the clustering feature\n     *\/\n    self.disable = function () {\n      if (enabled) {\n        enabled = false;\n        previousViewHash = '';\n        delayRedraw();\n      }\n    };\n\n    \/**\n     * Add a marker\n     * @param {Marker} marker\n     *\/\n    self.add = function (marker) {\n      markers.push(marker);\n      previousViewHash = '';\n      delayRedraw();\n    };\n\n    \/**\n     * Remove a marker\n     * @param {Marker} marker\n     *\/\n    self.remove = function (marker) {\n      markers = markers.filter(function (item) {\n        return item !== marker;\n      });\n      previousViewHash = '';\n      delayRedraw();\n    };\n\n    \/**\n     * Filtering function, Cluster only handle those who return true\n     * @callback filterCallback\n     * @param {Marker} marker\n     * @returns {Boolean}\n     *\/\n\n    \/**\n     * Set a filter function\n     * @param {filterCallback} fn\n     *\/\n    self.filter = function (fn) {\n      if (filter !== fn) {\n        filter = fn;\n        previousViewHash = '';\n        delayRedraw();\n      }\n    };\n\n    \/**\n     * Generate extended visible bounds\n     * @returns {LatLngBounds}\n     *\/\n    function extendsMapBounds() {\n      var circle = gmElement('Circle', {\n        center: map.getCenter(),\n        radius: 1.15 * distanceInMeter(map.getCenter(), map.getBounds().getNorthEast()) \/\/ + 15%\n      });\n      return circle.getBounds();\n    }\n\n    \/**\n     * Generate bounds extended by radius\n     * @param {LatLng} latLng\n     * @returns {LatLngBounds}\n     *\/\n    function extendsBounds(latLng) {\n      var p = projection.fromLatLngToDivPixel(latLng);\n      return gmElement('LatLngBounds',\n        projection.fromDivPixelToLatLng(gmElement('Point', p.x - radius, p.y + radius)),\n        projection.fromDivPixelToLatLng(gmElement('Point', p.x + radius, p.y - radius))\n      );\n    }\n\n    options.markers.map(function (opts) {\n      opts.position = toLatLng(opts.position);\n      markers.push(gmElement('Marker', opts));\n    });\n\n    \/**\n     * Redraw clusters\n     *\/\n    function redraw() {\n      var keys, bounds, overlayOptions, hash, currentMarkers, viewHash,\n        zoom = map.getZoom(),\n        currentHashes = {},\n        newOverlays = [],\n        ignore = {};\n\n      viewHash = '' + zoom;\n\n      if (zoom > 3) {\n        bounds = extendsMapBounds();\n        foreach(markers, function (marker, index) {\n          if (!bounds.contains(marker.getPosition())) {\n            viewHash += '-' + index;\n            ignore[index] = true;\n            if (marker.getMap()) {\n              marker.setMap(null);\n            }\n          }\n        });\n      }\n      if (filter) {\n        foreach(markers, function (marker, index) {\n          if (!ignore[index] && !filter(marker)) {\n            viewHash += '-' + index;\n            ignore[index] = true;\n            if (marker.getMap()) {\n              marker.setMap(null);\n            }\n          }\n        });\n      }\n\n      if (viewHash === previousViewHash) {\n        return;\n      }\n      previousViewHash = viewHash;\n\n      foreach(markers, function (marker, index) {\n        if (ignore[index]) {\n          return;\n        }\n\n        keys = [index];\n        bounds = extendsBounds(marker.getPosition());\n\n        if (enabled) {\n          foreach(slice(markers, index + 1), function (marker, idx) {\n            idx += index + 1;\n            if (!ignore[idx] && bounds.contains(marker.getPosition())) {\n              keys.push(idx);\n              ignore[idx] = true;\n            }\n          });\n        }\n\n        hash = keys.join('-');\n        currentHashes[hash] = true;\n\n        if (overlays[hash]) { \/\/ hash is already set\n          return;\n        }\n\n        currentMarkers = keys.map(function (key) {\n          return markers[key];\n        });\n\n        \/\/ ask the user callback on this subset (may be composed by only one marker)\n        overlayOptions = options.cb(slice(currentMarkers));\n\n        \/\/ create an overlay if cb returns its properties\n        if (overlayOptions) {\n          bounds = gmElement('LatLngBounds');\n          foreach(currentMarkers, function (marker) {\n            bounds.extend(marker.getPosition());\n            if (marker.getMap()) {\n              marker.setMap(null);\n            }\n          });\n\n          overlayOptions = dupOpts(overlayOptions);\n          overlayOptions.position = bounds.getCenter();\n          overlays[hash] = new ClusterOverlay(self, slice(currentMarkers), createOverlayView(map, overlayOptions), bounds);\n          newOverlays.push(overlays[hash]);\n\n        } else {\n          foreach(currentMarkers, function (marker) {\n            if (!marker.getMap()) { \/\/ to avoid marker blinking\n              marker.setMap(map);\n            }\n          });\n        }\n\n      });\n\n      \/\/ remove previous overlays\n      foreach(objectKeys(overlays), function (key) {\n        if (!currentHashes[key]) {\n          overlays[key].overlay.setMap(null);\n          delete overlays[key];\n        }\n      });\n\n      if (newOverlays.length) {\n        foreach(handlers, function (fn) {\n          fn(newOverlays);\n        });\n      }\n    }\n\n    \/**\n     * Restart redraw timer\n     *\/\n    function delayRedraw() {\n      clearTimeout(timer);\n      timer = setTimeout(redraw, 100);\n    }\n\n    \/**\n     * Init clustering\n     *\/\n    function init() {\n      gm.event.addListener(map, \"zoom_changed\", delayRedraw);\n      gm.event.addListener(map, \"bounds_changed\", delayRedraw);\n      redraw();\n    }\n\n    igniter = setInterval(function () {\n      projection = getProjection(map);\n      if (projection) {\n        clearInterval(igniter);\n        init();\n      }\n    }, 10);\n  }\n\n  \/**\n   * Configure google maps loading library\n   * @param {string|object} options\n   *\/\n  $.gmap3 = function (options) {\n    loadOptions = options;\n  };\n\n  \/**\n   * jQuery Plugin\n   *\/\n  $.fn.gmap3 = function (options) {\n    var items = [];\n    gm = window.google.maps; \/\/ once gmap3 is loaded, google.maps library should be loaded\n    this.each(function () {\n      var $this = $(this), gmap3 = $this.data(\"gmap3\");\n      if (!gmap3) {\n        gmap3 = new Gmap3($this, options);\n        $this.data(\"gmap3\", gmap3);\n      }\n      items.push(gmap3);\n    });\n\n    return new Handler(this, items);\n  };\n\n  \/**\n   * Class Handler\n   * Chainable objet which handle all Gmap3 items associated to all jQuery elements in the current command set\n   * @param {jQuery} chain - \"this\" to return to maintain the jQuery chain\n   * @param {Gmap3[]} items\n   * @constructor\n   *\/\n  function Handler(chain, items) {\n    var self = this;\n\n    \/\/ Map all functions from Gmap3 class\n    objectKeys(items[0]).forEach(function (name) {\n      self[name] = function () {\n        var results = [],\n          args = slice(arguments);\n        items.forEach(function (item) {\n          results.push(item[name].apply(item, args));\n        });\n        return name === 'get' ? (results.length > 1 ? results : results[0]) : self;\n      };\n    });\n\n    self.$ = chain;\n  }\n\n  \/**\n   * Class Gmap3\n   * Handle a Google.maps.Map instance\n   * @param {jQuery} $container - Element to display the map in\n   * @param {Object} options - MapOptions\n   * @constructor\n   *\/\n  function Gmap3($container, options) {\n    var map,\n      previousResults = [],\n      promise = when(),\n      self = this;\n\n    function context() {\n      return {\n        $: $container,\n        get: self.get\n      };\n    }\n\n    \/**\n     * Attach events to instances\n     * @param {Object } events\n     * @param {Array|Object} instances\n     * @param {array} [args] arguments to add\n     * @param {Boolean} once\n     *\/\n    function attachEvents(events, instances, args, once) {\n      var hasArgs = arguments.length > 3;\n      if (!hasArgs) {\n        once = args;\n      }\n      $.each(events, function (eventName, handlers) {\n        foreach(instances, function (instance) {\n          var isClusterOverlay = instance instanceof ClusterOverlay;\n          var isDom = isClusterOverlay ||\u00a0(instance instanceof gm.OverlayView);\n          var eventListener = isDom ? instance.$.get(0) : instance;\n          gm.event['add' + (isDom ? 'Dom' : '') + 'Listener' + (once ? 'Once' : '')](eventListener, eventName, function (event) {\n            foreach(handlers, function (handler) {\n              if (isFunction(handler)) {\n                if (isClusterOverlay) {\n                  handler.call(context(), undefined \/* marker *\/, instance, instance.cluster, event);\n                } else if (hasArgs) {\n                  var buffer = slice(args);\n                  buffer.unshift(instance);\n                  buffer.push(event);\n                  handler.apply(context(), buffer);\n                } else {\n                  handler.call(context(), instance, event);\n                }\n              }\n            });\n          });\n        });\n      });\n    }\n\n    \/**\n     * Decorator to handle multiple call based on array of options\n     * @param {Function} fn\n     * @returns {Deferred}\n     *\/\n    function multiple(fn) {\n      return function (options) {\n        if (isArray(options)) {\n          var instances = [];\n          var promises = options.map(function (opts) {\n            return fn.call(self, opts).then(function (instance) {\n              instances.push(instance);\n            });\n          });\n          return all(promises).then(function () {\n            previousResults.push(instances);\n            return instances;\n          });\n        } else {\n          return fn.apply(self, arguments).then(function (instance) {\n            previousResults.push(instance);\n            return instance;\n          });\n        }\n      };\n    }\n\n    \/**\n     * Decorator to chain promise result onto the main promise chain\n     * @param {Function} fn\n     * @returns {Deferred}\n     *\/\n    function chainToPromise(fn) {\n      return function () {\n        var args = slice(arguments);\n        promise = promise.then(function (instance) {\n          if (isFunction(args[0])) {\n            \/\/ handle return as a deferred \/ promise to support both sync & async result\n            return when(args[0].call(context(), instance)).then(function (value) {\n              args[0] = value;\n              return fn.apply(self, args);\n            });\n          }\n\n          return when(fn.apply(self, args));\n        });\n        return promise;\n      };\n    }\n\n    self.map = chainToPromise(function (options) {\n      return map || resolveLatLng(options, 'center', function (opts) {\n          map = gmElement('Map', $container.get(0), opts);\n          previousResults.push(map);\n          return map;\n        });\n    });\n\n    \/\/ Space separated string of : separated element\n    \/\/ (google.maps class name) : (latLng property name) : (add map - 0|1 - default = 1)\n    foreachStr('Marker:position Circle:center InfoWindow:position:0 Polyline:path Polygon:paths', function (item) {\n      item = item.split(':');\n      var property = item[1] || '';\n      self[item[0].toLowerCase()] = chainToPromise(multiple(function (options) {\n        return (property.match(\/^path\/) ? resolveArrayOfLatLng : resolveLatLng)(options, property, function (opts) {\n          if (item[2] !== '0') {\n            opts.map = map;\n          }\n          return gmElement(item[0], opts);\n        });\n      }));\n    });\n\n    foreachStr('TrafficLayer TransitLayer BicyclingLayer', function (item) {\n      self[item.toLowerCase()] = chainToPromise(function () {\n        var instance = gmElement(item);\n        previousResults.push(instance);\n        instance.setMap(map);\n        return instance;\n      });\n    });\n\n    self.kmllayer = chainToPromise(multiple(function (options) {\n      options = dupOpts(options);\n      options.map = map;\n      return when(gmElement('KmlLayer', options));\n    }));\n\n    self.rectangle = chainToPromise(multiple(function (options) {\n      return resolveLatLngBounds(options, function (opts) {\n        opts.map = map;\n        return gmElement('Rectangle', opts);\n      });\n    }));\n\n    self.overlay = chainToPromise(multiple(function (options) {\n      function fn(opts) {\n        return createOverlayView(map, opts);\n      }\n\n      options = dupOpts(options);\n      return options.bounds ? resolveLatLngBounds(options, fn) : resolveLatLng(options, 'position', fn);\n    }));\n\n    self.groundoverlay = chainToPromise(function (url, bounds, options) {\n      return resolveLatLngBounds({bounds: bounds}, function (opts) {\n        options = dupOpts(options);\n        options.map = map;\n        var instance = gmElement('GroundOverlay', url, opts.bounds, options);\n        previousResults.push(instance);\n        return instance;\n      });\n    });\n\n    self.styledmaptype = chainToPromise(function (styleId, styles, options) {\n      var instance = gmElement('StyledMapType', styles, options);\n      previousResults.push(instance);\n      map.mapTypes.set(styleId, instance);\n      return instance;\n    });\n\n    self.streetviewpanorama = chainToPromise(function (container, options) {\n      return resolveLatLng(options, 'position', function (opts) {\n        var instance = gmElement('StreetViewPanorama', $(container).get(0), opts);\n        map.setStreetView(instance);\n        previousResults.push(instance);\n        return instance;\n      });\n    });\n\n    self.route = chainToPromise(function (options) {\n      var dfd = deferred();\n      options = dupOpts(options);\n      options.origin = toLatLng(options.origin);\n      options.destination = toLatLng(options.destination);\n      service('DirectionsService').route(options, function (results, status) {\n        previousResults.push(results);\n        dfd.resolve(status === gm.DirectionsStatus.OK ? results : false);\n      });\n      return dfd;\n    });\n\n    self.cluster = chainToPromise(function (options) {\n      var cluster = new Cluster(map, dupOpts(options));\n      previousResults.push(cluster);\n      return resolved(cluster);\n    });\n\n    self.directionsrenderer = chainToPromise(function (options) {\n      var instance;\n      if (options) {\n        options = dupOpts(options);\n        options.map = map;\n        if (options.panel) {\n          options.panel = $(options.panel).get(0);\n        }\n        instance = gmElement('DirectionsRenderer', options);\n      }\n      previousResults.push(instance);\n      return instance;\n    });\n\n    self.latlng = chainToPromise(multiple(function (options) {\n      return resolveLatLng(options, 'latlng', function (opts) {\n        previousResults.push(opts.latlng);\n        return opts.latlng;\n      });\n    }));\n\n    self.fit = chainToPromise(function () {\n      var bounds = gmElement('LatLngBounds');\n      foreach(previousResults, function (instances) {\n        if (instances !== map) {\n          foreach(instances, function (instance) {\n            if (instance) {\n              if (instance.getPosition && instance.getPosition()) {\n                bounds.extend(instance.getPosition());\n              } else if (instance.getBounds && instance.getBounds()) {\n                bounds.extend(instance.getBounds().getNorthEast());\n                bounds.extend(instance.getBounds().getSouthWest());\n              } else if (instance.getPaths && instance.getPaths()) {\n                foreach(instance.getPaths().getArray(), function (path) {\n                  foreach(path.getArray(), function (latLng) {\n                    bounds.extend(latLng);\n                  });\n                });\n              } else if (instance.getPath && instance.getPath()) {\n                foreach(instance.getPath().getArray(), function (latLng) {\n                  bounds.extend(latLng);\n                });\n              } else if (instance.getCenter && instance.getCenter()) {\n                bounds.extend(instance.getCenter());\n              }\n            }\n          });\n        }\n      });\n      if (!bounds.isEmpty()) {\n        map.fitBounds(bounds);\n      }\n      return true;\n    });\n\n    self.wait = function (duration) {\n      promise = promise.then(function (instance) {\n        var dfd = deferred();\n        setTimeout(function () {\n          dfd.resolve(instance);\n        }, duration);\n        return dfd;\n      });\n    };\n\n    self.then = function (fn) {\n      if (isFunction(fn)) {\n        promise = promise.then(function (instance) {\n          return when(fn.call(context(), instance)).then(function (newInstance) {\n            return isUndefined(newInstance) ? instance : newInstance;\n          });\n        });\n      }\n    };\n\n    foreachStr('on once', function (name, once) {\n      self[name] = function () {\n        var events = arguments[0];\n        if (events) {\n          if (typeof events === 'string') { \/\/ cast call on('click', handler) to on({click: handler})\n            events = {};\n            events[arguments[0]] = slice(arguments, 1);\n          }\n          promise.then(function (instances) {\n            if (instances) {\n              if (instances instanceof Cluster) {\n                instances._b(function (items) {\n                  if (items && items.length) {\n                    attachEvents(events, items, once);\n                  }\n                });\n                return attachEvents(events, instances.markers(), [undefined, instances], once);\n              }\n              attachEvents(events, instances, once);\n            }\n          });\n        }\n      };\n    });\n\n    self.get = function (index) {\n      if (isUndefined(index)) {\n        return previousResults.map(function (instance) {\n          return isArray(instance) ? instance.slice() : instance;\n        });\n      } else {\n        if (index < 0) {\n          index = previousResults.length + index;\n        }\n        return isArray(previousResults[index]) ? previousResults[index].slice() : previousResults[index];\n      }\n    };\n\n    if (options) {\n      self.map(options);\n    }\n  }\n\n})(jQuery, window, document);\n","status":true}